<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Gravity Exploration</title>
    <style>
        body {
            font-family: 'Times New Roman', serif;
            background-color: white;
            color: #333;
            padding: 20px;
            line-height: 1.6;
            text-align: justify;
        }
        h1, h2 {
            color: #000;
        }
        .content-section {
            margin-bottom: 20px;
        }
        #dieGrid, #simulationResult {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(20px, 1fr));
            gap: 5px;
            margin-top: 10px;
        }
        .dieResult, .entryDecision {
            text-align: center;
            padding: 5px;
            border: 1px solid #ddd;
        }
        @media screen and (max-width: 600px) {
            #dieGrid, #simulationResult {
                grid-template-columns: repeat(auto-fill, minmax(10px, 1fr));
            }
        }
    </style>
</head>
<body>
    <h1>Quantum Gravity Exploration</h1>
    
    <!-- Quantum Physics and Observer Influence Section -->
    <section class="content-section" id="quantumPhysicsSection">
        <h2>Quantum Physics and Observer Influence</h2>
        <p>
            At the core of our exploration is the equation: O<sub>ŒºŒΩ</sub> = 1/2(g<sub>ŒºŒΩ</sub> + u<sub>Œº</sub>u<sub>ŒΩ</sub>). This equation represents the Observer Influence Tensor, O<sub>ŒºŒΩ</sub>, a concept that integrates the observer's influence into the fabric of spacetime.
        </p>
        <p>
            The Observer Influence Tensor, represented by O<sub>ŒºŒΩ</sub> = 1/2(g<sub>ŒºŒΩ</sub> + u<sub>Œº</sub>u<sub>ŒΩ</sub>), is a pivotal concept in quantum mechanics and general relativity. It merges spacetime's inherent structure, defined by the metric tensor g<sub>ŒºŒΩ</sub>, with the dynamic influence of an observer, characterized by the four-velocity u<sub>Œº</sub>. This equation symbolizes how observers are not mere bystanders but active participants in the universe, influencing the very fabric of spacetime through their presence and motion.
        </p>
    </section>

    <!-- Methodology and Application in Webpage -->
    <section class="content-section" id="methodologyApplication">
        <h2>Methodology and Webpage Application</h2>
        <p>
            The website's interactive elements, such as the Quantum Die simulation, are designed to demonstrate these theoretical concepts in a tangible way. Visitors can engage with simulations that dynamically reflect the principles of the Observer Influence Tensor, offering an immersive educational experience.
        </p>
        <p>
            These interactive tools, combined with the detailed theoretical explanations, provide a unique platform for both enthusiasts and researchers to explore the intriguing world of quantum gravity and the observer's role in it.
        </p>
    </section>

    <!-- Quantum Die Roll Section -->
    <section class="content-section" id="quantumDieRoll">
        <h2>Quantum Die Roll</h2>
        <button onclick="rollQuantumDie()">Roll Quantum Die</button>
        <div id="dieGrid"></div>
    </section>

    <!-- Berghain Door Policy Simulation Section -->
    <section class="content-section" id="berghainPolicySimulation">
        <h2>Berghain Gate Simulation</h2>
        <label for="appearance">Appearance (1-10):</label>
        <input type="number" id="appearance" name="appearance" min="1" max="10"><br/>
        <label for="knowledge">Music Knowledge (1-10):</label>
        <input type="number" id="knowledge" name="knowledge" min="1" max="10"><br/>
        <label for="age">Age:</label>
        <input type="number" id="age" name="age" min="18" max="100"><br/>
        <label for="bodyTemp">Body Temperature (1-3):</label>
        <input type="number" id="bodyTemp" name="bodyTemp" min="1" max="3"><br/>
        <button onclick="simulateEntryDecision()">Simulate Entry Decision</button>
        <div id="simulationResult"></div>
    </section>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
           let audioContext, gainNode, canvas, ctx, quantumLoop, modulationFactor = 1, quantumStates = [];
        let scene, camera, renderer, cube;

        function initAudioContext() {
            window.AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            gainNode = audioContext.createGain();
            gainNode.connect(audioContext.destination);
        }

        function runQuantumDie() {
            if (quantumStates.length >= 4000) quantumStates.shift();
            const array = new Uint8Array(1);
            window.crypto.getRandomValues(array);
            const outcome = array[0] % 3;
            quantumStates.push(outcome);
            displayQuantumOutput(outcome);
            playQuantumSound(outcome);
            drawCanvas();
            updateCubeRotation(outcome);
        }

        function displayQuantumOutput(outcome) {
            const outputElement = document.getElementById('die-output');
            const className = ['state-H', 'state-ùïè', 'state-plus'];
            const displayChar = ['H', 'ùïè', '+'];
            const newSpan = document.createElement('span');
            newSpan.className = className[outcome];
            newSpan.textContent = displayChar[outcome];
            outputElement.appendChild(newSpan);
            outputElement.scrollTop = outputElement.scrollHeight;
        }

        function playQuantumSound(state) {
    const oscillator1 = audioContext.createOscillator();
    const oscillator2 = audioContext.createOscillator();
    oscillator1.type = 'sine'; // Base oscillator
    oscillator2.type = ['sine', 'triangle', 'square'][state]; // Timbre modulating oscillator

    // Adjust frequencies to modify timbre
    oscillator1.frequency.setValueAtTime((440 + state * 110) * modulationFactor, audioContext.currentTime);
    oscillator2.frequency.setValueAtTime((220 + state * 55) * modulationFactor, audioContext.currentTime);

    // Create a gain node for the second oscillator to control its volume
    const gainNode2 = audioContext.createGain();
    gainNode2.gain.value = 0.5; // Adjust to blend the timbre

    // Connect and start the oscillators
    oscillator1.connect(gainNode);
    oscillator2.connect(gainNode2);
    gainNode2.connect(gainNode);
    oscillator1.start();
    oscillator2.start();
    oscillator1.stop(audioContext.currentTime + 0.2);
    oscillator2.stop(audioContext.currentTime + 0.2);
}
        function drawCanvas() {
            const stateWidth = 1;
            const canvasWidth = Math.max(4000, stateWidth * quantumStates.length);
            const maxHeight = 100;
            canvas.width = canvasWidth;
            const midPoint = canvas.height / 2;

            ctx.clearRect(0, 0, canvasWidth, canvas.height);
            quantumStates.forEach((state, index) => {
                const lineLength = Math.random() * maxHeight;
                ctx.fillStyle = ['blue', 'green', 'red'][state];
                ctx.fillRect(index * stateWidth, midPoint - lineLength / 2, stateWidth, lineLength);
            });
        }

        function updateModulation(value) {
            modulationFactor = value;
            gainNode.gain.value = Math.exp(value - 1);
        }

        function initCube() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.z = 5;
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(300, 300);
            renderer.setClearColor(0xAAAAAA);
            document.getElementById('cube-container').appendChild(renderer.domElement);

            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true });
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            loadCubeSymbols();
        }

        function loadCubeSymbols() {
            const loader = new THREE.FontLoader();
            loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', font => {
                addTextToCube(font, 'H', -0.5, 0, 0.5, 0, Math.PI / 2, 0);
                addTextToCube(font, 'ùïè', 0.5, 0, 0.5, 0, -Math.PI / 2, 0);
                addTextToCube(font, '+', 0, 0.5, 0.5, -Math.PI / 2, 0, 0);
            });
        }

        function addTextToCube(font, text, x, y, z, rotationX, rotationY, rotationZ) {
            const textGeometry = new THREE.TextGeometry(text, { font: font, size: 0.4, height: 0.1 });
            textGeometry.computeBoundingBox();
            const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
            const textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;
            const textMesh = new THREE.Mesh(textGeometry, new THREE.MeshBasicMaterial({ color: 0x000000 }));
            textMesh.position.set(x - textWidth / 2, y - textHeight / 2, z);
            textMesh.rotation.set(rotationX, rotationY, rotationZ);
            cube.add(textMesh);
        }

        function animateCube() {
            requestAnimationFrame(animateCube);
            renderer.render(scene, camera);
        }

        function updateCubeRotation(outcome) {
            cube.rotation.x += outcome * 0.05;
            cube.rotation.y += outcome * 0.05;
        }

        window.startQuantumDie = function() {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            clearInterval(quantumLoop);
            quantumStates = [];
            quantumLoop = setInterval(runQuantumDie, 200);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

        window.updateModulation = function(value) {
            modulationFactor = value;
            gainNode.gain.value = Math.exp(value - 1);
        };

        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('waveform');
            ctx = canvas.getContext('2d');
            initAudioContext();
            initCube();
            animateCube();
        });
    </script>
</body>
</html>
